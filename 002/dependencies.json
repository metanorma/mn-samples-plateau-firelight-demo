{
    "file:/Volumes/MNFirelight/firelight/packages/metanorma-xml-store": "// ../../../../../var/folders/ln/tn8s27hd7pg4_jx4_49rctfc0000gp/T/anafero-dist-file__Volumes_MNFirelight_firelight_packages_metanorma_xml_store-gjZXDm/index.mts\nimport {\n  ROOT_SUBJECT as ROOT_SUBJECT2\n} from \"anafero/index.mjs\";\n\n// ../../../../../private/var/folders/ln/tn8s27hd7pg4_jx4_49rctfc0000gp/T/anafero-dist-file__Volumes_MNFirelight_firelight_packages_metanorma_xml_store-gjZXDm/util.mts\nimport {\n  ROOT_SUBJECT\n} from \"anafero/index.mjs\";\nfunction estimateRelationCount(doc) {\n  let current = doc.documentElement;\n  let count = 0;\n  const processed = /* @__PURE__ */ new Set();\n  while (current !== null) {\n    if (!processed.has(current)) {\n      count += 1;\n      count += current.attributes.length;\n      processed.add(current);\n    }\n    current = (current.firstElementChild && !processed.has(current.firstElementChild) ? current.firstElementChild : null) ?? current.nextElementSibling ?? current.parentElement ?? null;\n  }\n  return count;\n}\nvar RESOURCE_URI_MAP = /* @__PURE__ */ new Map();\nvar REPORT_EVERY_N = 200;\nvar RETURNED_RELATION_CHUNK_SIZE = 1e3;\nfunction processResources(doc, onRelationChunk, rules, opts) {\n  function getURI_(el) {\n    if (!RESOURCE_URI_MAP.has(el)) {\n      RESOURCE_URI_MAP.set(\n        el,\n        el === doc.documentElement ? \"_:root\" : getURI(el, rules.getResourceURI, rules.getResourceURIFromID)\n      );\n    }\n    return RESOURCE_URI_MAP.get(el);\n  }\n  let current = doc.documentElement;\n  const currentChain = [repr(current)];\n  const processed = /* @__PURE__ */ new Set();\n  let sinceLastReport = 0;\n  const chunk = /* @__PURE__ */ new Map();\n  while (current !== null) {\n    if (sinceLastReport > REPORT_EVERY_N) {\n      opts.onProgress(currentChain[currentChain.length - 1]);\n      sinceLastReport = 0;\n    } else {\n      sinceLastReport += 1;\n    }\n    const firstChild = current.firstElementChild;\n    if (firstChild && !processed.has(firstChild) && rules.processTag?.[firstChild.tagName] !== \"ignore\") {\n      current = firstChild;\n      currentChain.push(repr(firstChild));\n    } else {\n      if (processed.has(current)) {\n        throw new Error(\"Encountered an already processed element\");\n      }\n      const rule = rules.processTag?.[current.tagName];\n      if (rule !== \"ignore\" && rule !== \"bypass\") {\n        const [localGraph, doDefaultProcess] = rule ? rule(current, getURI_) : [[], true];\n        if (doDefaultProcess !== false) {\n          const rules_ = doDefaultProcess !== true ? { ...rules, ...doDefaultProcess } : rules;\n          localGraph.push(\n            ...processResource(current, getURI_, rules_)\n          );\n        }\n        const uri = getURI_(current);\n        const graph = localGraph.map(([s, p, o]) => [\n          s === ROOT_SUBJECT ? uri : s,\n          p,\n          o\n        ]);\n        graph.map((rel) => chunk.set(rel, true));\n        processed.add(current);\n      }\n      if (chunk.size > RETURNED_RELATION_CHUNK_SIZE) {\n        onRelationChunk(Array.from(chunk.keys()));\n        chunk.clear();\n      }\n      if (current.nextElementSibling) {\n        currentChain.pop();\n        currentChain.push(repr(current.nextElementSibling));\n      } else if (current.parentElement) {\n        currentChain.pop();\n      }\n      current = current.nextElementSibling ?? current.parentElement ?? null;\n    }\n  }\n  if (chunk.size > 0) {\n    onRelationChunk(Array.from(chunk.keys()));\n  }\n  if (currentChain.length > 0) {\n    console.warn(\"Leftover chain after XML processing loop\", currentChain);\n  }\n}\nfunction processResource(el, getURI2, rules) {\n  const graph = [];\n  graph.push([\n    ROOT_SUBJECT,\n    \"type\",\n    rules.resourceTypesByTagName?.[el.tagName] ?? el.tagName\n  ]);\n  graph.push(...Array.from(el.attributes).filter((attr) => rules.processAttribute?.[attr.name] !== \"skip\").map((attr) => [\n    ROOT_SUBJECT,\n    `has${dekebab(attr.name)}`,\n    attr.value\n  ]));\n  if (!rules.skipChildren?.(el)) {\n    addRelationsToChildren(el, graph, getURI2, rules);\n  }\n  return graph;\n}\nfunction addRelationsToChildren(el, graph, getURI2, rules) {\n  for (const node of Array.from(el.childNodes)) {\n    if (node.nodeType === 3 && node.textContent !== null) {\n      graph.push([ROOT_SUBJECT, \"hasPart\", node.textContent]);\n    } else if (node.nodeType === 1) {\n      const childEl = node;\n      if (rules.processTag?.[childEl.tagName] === \"bypass\") {\n        addRelationsToChildren(childEl, graph, getURI2, rules);\n      } else {\n        const childPredicate = rules.getChildPredicate?.(el, childEl) ?? \"hasPart\";\n        graph.push([\n          ROOT_SUBJECT,\n          childPredicate,\n          getURI2(childEl)\n        ]);\n      }\n    }\n  }\n}\nvar DEFAULT_URI_PREFIX = \"urn:x-xml-element:\";\nfunction getURI(el, overrideURI, overrideURIFromID) {\n  return overrideURI?.(el) ?? getURIDefault(el, overrideURIFromID);\n}\nfunction getURIDefault(el, overrideURIFromID) {\n  const maybeID = el.getAttribute(\"id\");\n  const prefix = `${DEFAULT_URI_PREFIX}${el.tagName}`;\n  return maybeID ? overrideURIFromID?.(maybeID) ?? `${prefix}#${maybeID}` : `${prefix}-${crypto.randomUUID()}`;\n}\nfunction dekebab(str) {\n  return str.charAt(0).toUpperCase() + str.slice(1).replace(/-./g, (x) => x[1]?.toUpperCase() ?? \"\");\n}\nfunction repr(el) {\n  const maybeID = el.getAttribute(\"id\");\n  return `${el.tagName}${maybeID ? `#${maybeID}` : \"\"}`;\n}\n\n// ../../../../../var/folders/ln/tn8s27hd7pg4_jx4_49rctfc0000gp/T/anafero-dist-file__Volumes_MNFirelight_firelight_packages_metanorma_xml_store-gjZXDm/index.mts\nfunction urnFromID(id) {\n  return `urn:x-metanorma-xml-id:${id}`;\n}\nvar tagNameAliases = {\n  \"p\": \"paragraph\",\n  \"ul\": \"unorderedList\",\n  \"ol\": \"orderedList\",\n  \"li\": \"listItem\",\n  \"tbody\": \"tableBody\",\n  \"thead\": \"tableHeader\",\n  \"table\": \"table\",\n  \"tr\": \"tableRow\",\n  \"th\": \"tableHeaderCell\",\n  \"td\": \"tableCell\",\n  \"g\": \"pathGroup\"\n};\nfunction mangleXMLIdentifier(id) {\n  return unescape(id.replaceAll(\"___x\", \"%u\").replaceAll(\"__x\", \"%u\"));\n}\nvar sectionLikeElements = [\n  \"clause\",\n  \"abstract\",\n  \"references\",\n  \"definitions\",\n  \"terms\"\n];\nvar mod = {\n  name: \"Metanorma XML store adapter\",\n  version: \"0.0.1\",\n  canResolve: (path) => path.endsWith(\".xml\"),\n  readerFromBlob: async function(blob, helpers) {\n    const dom = helpers.decodeXML(blob);\n    const processClauseLike = function processClauseLike2(el) {\n      return [\n        [[\n          ROOT_SUBJECT2,\n          \"hasClauseIdentifier\",\n          mangleXMLIdentifier(\n            el.getAttribute(\"id\") ?? `unidentified-section-${crypto.randomUUID()}`\n          )\n        ], [\n          ROOT_SUBJECT2,\n          \"type\",\n          \"section\"\n        ]],\n        {\n          getChildPredicate: () => \"hasPart\"\n        }\n      ];\n    };\n    const processAsGenericContainer = function processGeneric() {\n      return [[], { getChildPredicate: () => \"hasPart\" }];\n    };\n    function tagNameToHasPredicate(tagName) {\n      return `has${dekebab(tagNameAliases[tagName] ?? tagName)}`;\n    }\n    const TAGS_WITH_DIRECT_CHILDREN_NOT_AS_GENERIC_PARTS = [\n      \"bibdata\",\n      \"bibitem\",\n      \"figure\",\n      \"image\",\n      \"table\",\n      \"colgroup\",\n      \"thead\",\n      \"tbody\",\n      \"tr\"\n    ];\n    const TAGS_WITH_ALL_CHILDREN_NOT_AS_GENERIC_PARTS = [\n      \"bibdata\",\n      \"bibitem\"\n    ];\n    const TAGS_WITH_ALL_CHILDREN_NOT_AS_GENERIC_PARTS_SELECTOR = TAGS_WITH_ALL_CHILDREN_NOT_AS_GENERIC_PARTS.join(\", \");\n    return [\n      [],\n      {\n        estimateRelationCount: () => estimateRelationCount(dom),\n        discoverAllResources: (onRelationChunk, opts) => {\n          processResources(dom, onRelationChunk, {\n            getResourceURIFromID: urnFromID,\n            getChildPredicate: function getChildPredicate(el, childEl) {\n              if (TAGS_WITH_DIRECT_CHILDREN_NOT_AS_GENERIC_PARTS.includes(el.tagName) || childEl.closest(TAGS_WITH_ALL_CHILDREN_NOT_AS_GENERIC_PARTS_SELECTOR)) {\n                return tagNameToHasPredicate(childEl.tagName);\n              }\n              return void 0;\n            },\n            resourceTypesByTagName: tagNameAliases,\n            processTag: {\n              [dom.documentElement.tagName]: function processRootTag() {\n                return [\n                  [[ROOT_SUBJECT2, \"type\", \"document\"]],\n                  {\n                    getChildPredicate: (_, childEl) => childEl.tagName === \"bibdata\" ? tagNameToHasPredicate(childEl.tagName) : \"hasPart\"\n                  }\n                ];\n              },\n              abstract: function processAbstract(el, getURI2) {\n                if (!el.closest(\"bibdata\")) {\n                  return processClauseLike(el, getURI2);\n                } else {\n                  return processAsGenericContainer(el, getURI2);\n                }\n              },\n              formattedref: processAsGenericContainer,\n              span: processAsGenericContainer,\n              clause: function processClause(el, getURI2) {\n                if (el.getAttribute(\"type\") === \"toc\") {\n                  return [[], false];\n                } else {\n                  return processClauseLike(el, getURI2);\n                }\n              },\n              introduction: processClauseLike,\n              foreword: processClauseLike,\n              references: processClauseLike,\n              terms: processClauseLike,\n              definitions: processClauseLike,\n              xref: function processXref(el) {\n                const maybeTarget = el.getAttribute(\"target\");\n                const graph = [];\n                if (!maybeTarget) {\n                  console.warn(\"Xref with no target\", el);\n                } else {\n                  graph.push([ROOT_SUBJECT2, \"hasTarget\", urnFromID(maybeTarget)]);\n                }\n                return [graph, { processAttribute: { target: \"skip\" } }];\n              },\n              stem: function processStem(el) {\n                return [\n                  [[ROOT_SUBJECT2, \"hasMathML\", el.querySelector(\"math\").outerHTML]],\n                  { skipChildren: () => true }\n                ];\n              },\n              title: function processTitle(el, getURI2) {\n                if (el.parentElement && sectionLikeElements.includes(el.parentElement.tagName)) {\n                  const sectionURI = getURI2(el.parentElement);\n                  const clauseNumber = el.querySelector(\"tab\") ? el.childNodes[0]?.textContent ?? \"\" : \"\";\n                  const graph = [];\n                  if (clauseNumber.trim() !== \"\") {\n                    graph.push([sectionURI, \"hasClauseNumber\", clauseNumber]);\n                  }\n                  const parts = Array.from(el.childNodes).filter((n) => n.nodeType === 3).map((n) => n.textContent ?? \"\").filter((content) => content !== \"\" && content !== clauseNumber);\n                  if (parts.length > 0) {\n                    for (const part of parts) {\n                      graph.push([ROOT_SUBJECT2, \"hasPart\", part]);\n                    }\n                  } else {\n                    throw new Error(\"Processing title: no content found!\");\n                  }\n                  return [graph, { skipChildren: () => true }];\n                } else {\n                  return [[], true];\n                }\n              },\n              svg: function processSVG(el) {\n                return [\n                  [[ROOT_SUBJECT2, \"hasSVGContents\", el.outerHTML]],\n                  { skipChildren: () => true }\n                ];\n              },\n              preface: \"bypass\",\n              sections: \"bypass\",\n              annex: \"bypass\",\n              bibliography: \"bypass\",\n              metanorma: \"ignore\",\n              \"localized-strings\": \"ignore\",\n              \"presentation-metadata\": \"ignore\"\n            }\n          }, opts);\n        }\n      }\n    ];\n  }\n};\nvar anafero_dist_file_Volumes_MNFirelight_firelight_packages_metanorma_xml_store_gjZXDm_default = mod;\nexport {\n  anafero_dist_file_Volumes_MNFirelight_firelight_packages_metanorma_xml_store_gjZXDm_default as default\n};\n//# sourceMappingURL=index.js.map\n",
    "file:/Volumes/MNFirelight/firelight/packages/metanorma-site-content": "// ../../../../../var/folders/ln/tn8s27hd7pg4_jx4_49rctfc0000gp/T/anafero-dist-file__Volumes_MNFirelight_firelight_packages_metanorma_site_content-ZCVLpq/index.mts\nimport { Schema, Fragment } from \"prosemirror-model\";\nimport { tableNodes } from \"prosemirror-tables\";\nimport { addListNodes } from \"prosemirror-schema-list\";\nimport {\n  titleSchema,\n  ROOT_SUBJECT\n} from \"anafero/index.mjs\";\n\n// ../../../../../private/var/folders/ln/tn8s27hd7pg4_jx4_49rctfc0000gp/T/anafero-dist-file__Volumes_MNFirelight_firelight_packages_metanorma_site_content-ZCVLpq/nodeViews.tsx\nimport React from \"react\";\nimport { ResourceNavigationContext } from \"anafero/index.mjs\";\n\n// ../../../../../private/var/folders/ln/tn8s27hd7pg4_jx4_49rctfc0000gp/T/anafero-dist-file__Volumes_MNFirelight_firelight_packages_metanorma_site_content-ZCVLpq/style.css\nvar figCaption = \"style_figCaption\";\nvar docMeta = \"style_docMeta\";\n\n// ../../../../../private/var/folders/ln/tn8s27hd7pg4_jx4_49rctfc0000gp/T/anafero-dist-file__Volumes_MNFirelight_firelight_packages_metanorma_site_content-ZCVLpq/nodeViews.tsx\nvar makeResourceNodeView = (Tag) => React.forwardRef(function NodeViewMaybeRepresentingResource({\n  children,\n  nodeProps\n}, ref) {\n  const elID = nodeProps.node.attrs?.resourceID ? encodeURIComponent(nodeProps.node.attrs.resourceID) : void 0;\n  return /* @__PURE__ */ React.createElement(\n    Tag,\n    {\n      ref,\n      id: elID,\n      about: nodeProps.node.attrs?.resourceID\n    },\n    children\n  );\n});\nvar ResourceLinkView = React.forwardRef(function ResourceLinkView2({\n  children,\n  nodeProps\n}, ref) {\n  const navCtx = React.useContext(ResourceNavigationContext);\n  const href = nodeProps.node.attrs?.href;\n  let resolvedHref;\n  if (href.startsWith(\"http\") || href.startsWith(\"data:\")) {\n    console.warn(\"ResourceLinkView expects PM node\\u2019s href attribute to be a resource URI, but got\", href);\n    resolvedHref = null;\n  } else {\n    try {\n      resolvedHref = navCtx.locateResource(href);\n    } catch (e) {\n      console.warn(\"ResourceLinkView failed to locate resource\", href);\n      resolvedHref = null;\n    }\n  }\n  const [resourceRepr, setResourceRepr] = React.useState(children);\n  React.useEffect(() => {\n    if (!children && resolvedHref) {\n      const abortController = new AbortController();\n      (async () => {\n        try {\n          const title = await navCtx.resolvePlainTitle(resolvedHref, abortController.signal);\n          if (title) {\n            setResourceRepr(/* @__PURE__ */ React.createElement(React.Fragment, null, title));\n          }\n        } catch (e) {\n          console.error(\"Failed to resolve plain title\", e);\n        }\n      })();\n      return function cleanup() {\n        abortController.abort();\n      };\n    }\n    return;\n  }, [resolvedHref, children]);\n  return /* @__PURE__ */ React.createElement(\"a\", { ref, href: resolvedHref ?? href }, resourceRepr);\n});\nvar nodeViews = {\n  docMeta: React.forwardRef(function DocMetaNodeView({ children, nodeProps }, ref) {\n    return /* @__PURE__ */ React.createElement(\"div\", { className: docMeta, ref }, children);\n  }),\n  paragraph: makeResourceNodeView(\"p\"),\n  figure: makeResourceNodeView(\"figure\"),\n  bullet_list: makeResourceNodeView(\"ul\"),\n  ordered_list: makeResourceNodeView(\"ol\"),\n  resource_link: ResourceLinkView\n};\nvar nodeViews_default = nodeViews;\n\n// ../../../../../var/folders/ln/tn8s27hd7pg4_jx4_49rctfc0000gp/T/anafero-dist-file__Volumes_MNFirelight_firelight_packages_metanorma_site_content-ZCVLpq/index.mts\nvar tn = tableNodes({\n  tableGroup: \"block\",\n  cellContent: \"block*\",\n  cellAttributes: {\n    background: {\n      default: null,\n      getFromDOM(dom) {\n        return dom.style?.backgroundColor || null;\n      },\n      setDOMAttr(value, attrs) {\n        if (value)\n          attrs.style = (attrs.style || \"\") + `background-color: ${value};`;\n      }\n    }\n  }\n});\ntn.table.attrs = {\n  // Colgroup support.\n  colWidths: {\n    default: []\n  }\n};\ntn.table.toDOM = function(node) {\n  if ((node.attrs.colWidths ?? []).length > 0) {\n    const cols = node.attrs.colWidths.map(\n      (width) => [\"col\", { width }]\n    );\n    const colgroup = [\"colgroup\", ...cols];\n    return [\"table\", colgroup, [\"tbody\", 0]];\n  } else {\n    return [\"table\", [\"tbody\", 0]];\n  }\n};\nvar clauseSchemaBase = new Schema({\n  nodes: {\n    text: {\n      inline: true\n    },\n    doc: {\n      content: \"title block* parts?\",\n      parseDOM: [{ tag: \"article\" }],\n      toDOM() {\n        return [\"article\", 0];\n      }\n    },\n    title: {\n      content: \"text*\",\n      toDOM() {\n        return [\"h1\", 0];\n      }\n    },\n    paragraph: {\n      attrs: {\n        resourceID: {\n          default: \"\"\n        }\n      },\n      content: \"(text | flow)*\",\n      group: \"block\",\n      toDOM(node) {\n        const attrs = node.attrs.resourceID ? { about: node.attrs.resourceID } : {};\n        return [\"p\", attrs, 0];\n      }\n    },\n    source_listing: {\n      attrs: {\n        resourceID: {\n          default: \"\"\n        }\n      },\n      content: \"(text | flow)*\",\n      group: \"block\",\n      toDOM(node) {\n        const attrs = node.attrs.resourceID ? { about: node.attrs.resourceID } : {};\n        return [\"pre\", attrs, 0];\n      }\n    },\n    definition_list: {\n      content: \"(dt | dd)+\",\n      group: \"block\",\n      toDOM() {\n        return [\"dl\", 0];\n      }\n    },\n    dt: {\n      content: \"paragraph*\",\n      inline: false,\n      toDOM() {\n        return [\"dt\", 0];\n      }\n    },\n    dd: {\n      content: \"block*\",\n      toDOM() {\n        return [\"dd\", 0];\n      }\n    },\n    external_link: {\n      attrs: {\n        href: {\n          // Placeholder\n          default: \"https://example.com/\"\n        }\n      },\n      inclusive: false,\n      inline: true,\n      group: \"flow\",\n      content: \"(flow | text)*\",\n      toDOM(node) {\n        return [\"a\", {\n          href: node.attrs.href\n        }, node.textContent ? 0 : node.attrs.href];\n      }\n    },\n    figure: {\n      content: \"figCaption? (image | table)\",\n      group: \"block\",\n      attrs: {\n        resourceID: {\n          default: void 0\n        }\n      },\n      toDOM(node) {\n        const attrs = node.attrs.resourceID ? { about: node.attrs.resourceID } : {};\n        return [\"figure\", attrs, 0];\n      }\n    },\n    figCaption: {\n      content: \"text*\",\n      toDOM() {\n        return [\"figcaption\", { class: figCaption }, 0];\n      }\n    },\n    image: {\n      attrs: {\n        src: {\n          // Placeholder\n          default: \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAYAAABw4pVUAAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAZKADAAQAAAABAAAAZAAAAAAvu95BAAAGsklEQVR4Ae3cTUgbTRgH8Im0tSBSVKxeFFsrrSh6EezBg4KIF22r3ooUPPh986ZnKQi9K4Leqt5LBW960Ev0YD9oa1SkSKyKKFpQFJ93/+O720Q3m2yyHzObHWiy2dl9JvP8NjOTUDcQDAYpNzeXZWZmMr+4l4GLiwt2dHTE7gEDG8+ePWOPHj1y7x2lccsnJycsHA4zWGTgkwGMUCjEUOEXZzOAnCP3MIBFBprHJ8NHcRYCrUViqKMTB0Glj4IsOFf0MNC6BoIXPgqyYH+JhYGWo0Cww0dBFuwrRhho9Q4IdvooyIL1JR4GWtQFQYWPgixYVxLBQGsxQVDpoyALqZdEMdCSIQgO8FGQheSLGQy0EhcEB/koyIL5YhYDLSQEggN9FGQh8ZIMBqInDIKDfRRkIX5JFgORTYHgBB8FWYhdUsFAVNMgOMlHQRbullQxEDEpEJzooyAL/4oVGIiWNAhO9lGQBf1fbW9qzD+mBILm0h3Fqk+GSpcySDqjWI2BXFoCko4odmBYCpJOKHZhWA6SDih2YtgC4mUUuzFsA/EiihMYtoJ4CcUpDNtBvIDiJIYjIDKjOI3hGIiMKG5gOAoiE4pbGI6DyIDiJoYrICKjuI3hGoiIKCJguAoiEoooGK6DiIAiEoYQIG6iiIYhDIgbKCJiCAXiJIqoGMKBOIEiMoaQIHaiiI4hLIgdKDJgCA1iJYosGMKDWIEiE4YUIKmgyIYhDUgyKDJiSAViBkVWDOlAEkGRGUNKECMU2TGkBdFD8QIG+nUPD7KWyD+FQB+8cM8vy/73u6yoor1vqUEihymv3O9LWpBIDAxdkcMX6mQtUoLcxlCT7wUU6UBiYXgFRSqQeBheQJEGJFEM2VGkADGLITOK8CDJYsiKIjRIqhgyoggLYhWGbChCgliNIROKcCB2YciCIhSI3RgyoAgD4hSG6ChCgDiNITKK6yBuYYiK4iqI2xgiorgGIgqGaCiugIiGIRKK4yCiYoiC4iiI6BgioDgGIguG2yiOgMiG4SaK7SCyYriFYiuI7BhuoNgG4hUMp1FsAfEahpMoloN4FcMpFEtBvI7hBIplIOmCYTeKJSDphmEnSsog6YphF0pKIOmOYQdK0iA+hspx82zVn0IkBeJjRGOor6xAMQ3iY6jp139OFcUUiI+hj3B7byooCYPIgHFwcMC2trZu54e/3tzcZOFw2HSd7gn/7zRq7/DwkGVnZ7NQKMSQu8hyfHzMvn37xogocvfN9u7urrLfuCgBKBgMEp5FLp2dndTW1hb1Fvf396mqqgo95/+am5vp4uKCH2NUFxUkxotE2mtsbKSVlRUtd729vXT//n3+XgoKCujr169adFiweCAyYExNTVFLSwvv5G2Qt2/f0tOnT+nHjx+0vLxMylVLw8PDPAlGdVqWdDbMtjc0NMQv6I8fP1JGRgbNzMzQ79+/qaGhgcrKyrQW4oLIgIHeDA4OUmtrK+GKiwQ5Pz/nCZientY63dXVxYGM6tDvuro6QiJRrq6u6PXr19Td3c1fJ9MeYtbX11NTUxOPgYf5+Xl+Ea2urvJ9hiCyYGi9UzaAEgmC4QBD1c+fP7XDxsbGKBAI0Pr6esw6AIyPj/P6z58/0+joKD18+JC+fPmixcGGmfYQ8/nz59Tf368NX9vb27yN2dlZHhcguvc6kWECvzsb3t2jTvA5OTlaZUlJCZ9Mv3//zvfp1Z2dnbGenh726dMn9u7dOz4pf/jwgVVWVmpx9DaM2kPMnZ0d9uTJEz7R484TxcXFTBnC2OnpqRbuzirLKxjooTJ38I7++fNH6/Dfv3+ZMrRpydWrw7IV5f379wwrqcLCQjYwMKDFiLVh1B5iAgPJV28Doiwq2PX1NVM+OVrIKBAvYaCH5eXlfOm5sbGhdRjLzerqasM69eCRkRH2+PFjpkzAbHJyUt0d89moPZxUW1vLfv36pd0GZGFhgcdSVoH/YqqrLBnnjKgBXWdMRz2WnTU1NbS3t0dzc3OUl5dHypXPTzWqUwD4XLO4uMgXDVlZWaQkk5+nPtyeQ7DfKObExAQ9ePCAlpaW+HL35cuX9OLFC21O0SZ1L2AgGa9evaL29nZsakX5YkbKWM0nT0zmb9684asmHBCrDpMtAPr6+ngcZZij0tJSUq5wLS42zLZ3eXlJHR0d/L0oHwkqKiqitbU17TseQALKRERHR0eeuPnXv8999JaSO/7NOD8/n88fkbVGdZHHmdmOFxO/GCDnFRUVPKw6VeTm5rIAvoFjIzMz00yb/rEWZ0D59YAj/QfOk9kCdUvo/AAAAABJRU5ErkJggg==\"\n        }\n      },\n      toDOM(node) {\n        return [\"img\", {\n          src: node.attrs.src\n        }];\n      },\n      isLeaf: true\n    },\n    math: {\n      attrs: {\n        /** HTML markup, from the outer <math> tag and down. */\n        mathML: {\n          default: \"\"\n        }\n      },\n      inline: true,\n      group: \"flow\",\n      toDOM(node) {\n        const el = document.createElement(\"span\");\n        el.innerHTML = node.attrs.mathML;\n        return el;\n      }\n    },\n    ...tn,\n    // Table of subclauses\n    parts: {\n      content: \"part_entry+\",\n      toDOM(node) {\n        return [\"ul\", { class: \"toc\" }, 0];\n      }\n    },\n    part_entry: {\n      content: \"resource_link\",\n      toDOM() {\n        return [\"li\", 0];\n      }\n    },\n    span: {\n      group: \"flow\",\n      content: \"(text | flow)*\",\n      inline: true,\n      toDOM() {\n        return [\"span\", 0];\n      }\n    },\n    code: {\n      group: \"flow\",\n      content: \"(text | flow)*\",\n      inline: true,\n      toDOM() {\n        return [\"code\", 0];\n      }\n    },\n    resource_link: {\n      attrs: {\n        href: {\n          // Should be a resource ID/URI\n          // Would be resolved by node view or serialized DOM post-processor\n          default: void 0\n        }\n      },\n      inclusive: false,\n      inline: true,\n      group: \"flow\",\n      content: \"(text | flow)*\",\n      toDOM(node) {\n        return [\"a\", {\n          href: node.attrs.href\n        }, 0];\n      }\n    }\n  }\n});\nvar clauseSchema = new Schema({\n  nodes: addListNodes(\n    clauseSchemaBase.spec.nodes,\n    \"paragraph block*\",\n    \"block\"\n  ),\n  marks: clauseSchemaBase.spec.marks\n});\nvar collectionEntrySchema = new Schema({\n  nodes: {\n    text: {},\n    doc: {\n      content: \"title\",\n      toDOM() {\n        return [\"article\", 0];\n      }\n    },\n    title: {\n      content: \"text*\",\n      toDOM() {\n        return [\"h1\", 0];\n      }\n    }\n  }\n});\nvar coverBibdataSchema = new Schema({\n  nodes: {\n    text: {},\n    doc: {\n      content: \"docMeta mainTitle someOtherTitle*\",\n      parseDOM: [{ tag: \"article\" }],\n      toDOM() {\n        return [\"article\", 0];\n      }\n    },\n    mainTitle: {\n      content: \"text*\",\n      toDOM() {\n        return [\"h1\", 0];\n      }\n    },\n    someOtherTitle: {\n      content: \"text*\",\n      toDOM() {\n        return [\"p\", 0];\n      }\n    },\n    docMeta: {\n      content: \"primaryDocID edition pubDate author\",\n      toDOM() {\n        return [\"div\", { class: \"docMeta\", style: \"color: green;\" }, 0];\n      }\n    },\n    primaryDocID: {\n      content: \"text*\",\n      toDOM() {\n        return [\"div\", 0];\n      }\n    },\n    author: {\n      content: \"text*\",\n      toDOM() {\n        return [\"div\", 0];\n      }\n    },\n    edition: {\n      content: \"text*\",\n      toDOM() {\n        return [\"div\", 0];\n      }\n    },\n    pubDate: {\n      content: \"text*\",\n      toDOM() {\n        return [\"div\", 0];\n      }\n    }\n  },\n  marks: {}\n});\nfunction getCurrentLanguage(doc) {\n  const languages = resolveChain(doc, [\"hasBibdata\", \"hasLanguage\", \"hasPart\"]);\n  return languages.filter(\n    ([langID]) => findValue(doc, langID, \"hasCurrent\") === \"true\"\n  )[0]?.[1] ?? languages[0]?.[1] ?? void 0;\n}\nfunction getBibdataDocid(doc) {\n  const docids = resolveChain(doc, [\"hasBibdata\", \"hasDocidentifier\", \"hasPart\"]);\n  return docids.find(\n    ([uri]) => findValue(doc, uri, \"hasPrimary\") === \"true\"\n  )?.[1] ?? docids[0]?.[1];\n}\nfunction getSectionPlainTitle(section) {\n  const clauseNumber = resolveChain(section, [\"hasClauseNumber\"], ROOT_SUBJECT)[0]?.[1];\n  const parts = resolveChain(section, [\"hasPart\", \"type\"], ROOT_SUBJECT);\n  const plainTitleIDs = parts.filter(([pID, type]) => type === \"title\").map(([pID]) => pID);\n  const plainTitles = plainTitleIDs.map((id) => findAll(section, id, \"hasPart\").join(\" \"));\n  return plainTitles[0] ? `${clauseNumber ?? \"\"}${clauseNumber ? \"\\u2004\\u2004\" : \"\"}${plainTitles[0]}` : void 0;\n}\nvar mod = {\n  name: \"Metanorma site content\",\n  version: \"0.0.1\",\n  describe: (relations) => {\n    const primaryLanguageID = getCurrentLanguage(relations);\n    const labelInPlainText = getBibdataDocid(relations) ?? getSectionPlainTitle(relations) ?? relations.find(([s, p, o]) => s === ROOT_SUBJECT && p !== \"type\" && o.trim() !== \"\" && !o.startsWith(\"urn:\"))?.[2].slice(0, 20) ?? \"Untitled resource\";\n    return primaryLanguageID ? { labelInPlainText, primaryLanguageID } : { labelInPlainText };\n  },\n  contributingToHierarchy: [\n    [\"hasPart\", \"hasClauseIdentifier\"],\n    [\"hasPart\", \"hasBibdata\", \"hasDocidentifier\", \"hasPart\"]\n  ],\n  // This is not used currently?\n  contributesToContent: (relation, targetRelations) => {\n    return relation.predicate === \"hasPart\" || relation.predicate === \"hasText\";\n  },\n  generateContent: function(relations) {\n    const rootType = relations.find(([s, p]) => s === ROOT_SUBJECT && p === \"type\")?.[2];\n    if (!rootType) {\n      console.warn(\"Won\\u2019t generate content for a resource that lacks a type\");\n      throw new Error();\n    }\n    const generator = generatorsByType[rootType];\n    if (!generator) {\n      console.warn(\"Cannot generate content: unrecognized type\", rootType);\n      return null;\n    }\n    if (relations.length > 0) {\n    }\n    return generator(relations);\n  },\n  resourceContentProseMirrorSchema: {\n    cover: coverBibdataSchema,\n    clause: clauseSchema\n  },\n  resourceContentProseMirrorOptions: {\n    nodeViews: nodeViews_default\n  }\n};\nvar anafero_dist_file_Volumes_MNFirelight_firelight_packages_metanorma_site_content_ZCVLpq_default = mod;\nvar generatorsByType = {\n  document: function generateDoc(doc) {\n    const bibdataID = doc.find(([s, p]) => s === ROOT_SUBJECT && p === \"hasBibdata\")?.[2];\n    if (!bibdataID) {\n      throw new Error(\"Can\\u2019t generate content: document is missing bibdata\");\n    }\n    const docid = getBibdataDocid(doc);\n    if (!docid) {\n      throw new Error(\"Can\\u2019t generate content: bibdata is missing docid\");\n    }\n    const currentLanguage = getCurrentLanguage(doc);\n    if (!currentLanguage) {\n      throw new Error(\"Cannot generate document: missing current language\");\n    }\n    return generateCoverPage(currentLanguage, docid)(relativeGraph(doc, bibdataID));\n  },\n  section: function generateDoc2(section) {\n    const labelInPlainText = getSectionPlainTitle(section);\n    if (!labelInPlainText) {\n      throw new Error(\"Cannot generate clause: missing title\");\n    }\n    const simpleNodes = {\n      \"unorderedList\": \"bullet_list\",\n      \"orderedList\": \"ordered_list\",\n      \"paragraph\": \"paragraph\",\n      \"sourcecode\": \"source_listing\",\n      \"span\": \"span\",\n      \"dl\": \"definition_list\",\n      \"dd\": \"dd\",\n      \"dt\": \"dt\",\n      \"tt\": \"code\"\n      //'tableCell': 'table_cell',\n    };\n    const customNodes = {\n      \"link\": (subj) => {\n        const target = findValue(section, subj, \"hasTarget\");\n        if (!target) {\n          console.warn(\"Cannot create a link without target/href\");\n          return void 0;\n        }\n        if (target.startsWith(\"http\")) {\n          return pm.node(\"external_link\", { href: target }, generateContent(subj, pm.nodes.external_link));\n        } else {\n          console.warn(\"Unexpected link target!\", target);\n          return void 0;\n        }\n      },\n      \"stem\": (subj) => {\n        const mathML = findValue(section, subj, \"hasMathML\");\n        return pm.node(\"math\", { mathML });\n      },\n      \"xref\": (subj) => {\n        const target = findValue(section, subj, \"hasTarget\");\n        if (!target) {\n          console.warn(\"Cannot create a resource link without target/href\");\n          return void 0;\n        }\n        return pm.node(\"resource_link\", { href: target }, generateContent(subj, pm.nodes.resource_link));\n      },\n      \"table\": (subj) => {\n        const name = findValue(section, subj, \"hasName\");\n        const caption = name ? findValue(section, name, \"hasPart\") : null;\n        const tbody = findValue(section, subj, \"hasTableBody\");\n        const thead = findValue(section, subj, \"hasTableHeader\");\n        let rows = [];\n        if (thead) {\n          rows.push(...findAll(section, thead, \"hasTableRow\"));\n        }\n        if (!tbody) {\n          console.warn(\"Tables without tbody are not expected\");\n          rows.push(...findAll(section, subj, \"hasTableRow\"));\n        } else {\n          rows.push(...findAll(section, tbody, \"hasTableRow\"));\n        }\n        const tableContents = [];\n        let colWidths = [];\n        const colgroup = findValue(section, subj, \"hasColgroup\");\n        if (colgroup) {\n          const maybeColWidths = findAll(section, colgroup, \"hasCol\").map(\n            (colID) => findValue(section, colID, \"hasWidth\")\n          ).filter((v) => v !== void 0 && v !== null);\n          if (maybeColWidths.length > 0) {\n            colWidths = maybeColWidths;\n          }\n        }\n        tableContents.push(...rows.map(\n          (rowID) => pm.node(\n            \"table_row\",\n            null,\n            findAll(\n              section,\n              rowID,\n              [\"hasTableCell\", \"hasTableHeaderCell\"]\n            ).map(\n              (cellID) => pm.node(\n                findValue(section, cellID, \"type\") === \"tableHeaderCell\" ? \"table_header\" : \"table_cell\",\n                {\n                  colspan: findValue(section, cellID, \"hasColspan\"),\n                  rowspan: findValue(section, cellID, \"hasRowspan\")\n                },\n                generateContent(cellID, pm.nodes.table_cell)\n              )\n            )\n          )\n        ));\n        if (tableContents.length < 1) {\n          return void 0;\n        }\n        const contents = [\n          pm.node(\n            \"table\",\n            colWidths ? { colWidths } : null,\n            tableContents\n          )\n        ];\n        if (caption && !hasSubject(section, caption)) {\n          contents.splice(0, 0, pm.node(\"figCaption\", null, [pm.text(caption)]));\n        }\n        return pm.node(\"figure\", { resourceID: subj }, contents);\n      },\n      \"bibitem\": (subj) => {\n        const contents = [];\n        const tagSubj = findValue(section, subj, \"hasBiblioTag\");\n        const tag = tagSubj ? findValue(section, tagSubj, \"hasPart\") : null;\n        if (tag) {\n          contents.push(pm.node(\"span\", null, [pm.text(tag), pm.text(\" \")]));\n        }\n        const formattedref = findValue(section, subj, \"hasFormattedref\");\n        if (formattedref) {\n          contents.push(...generateContent(formattedref, pm.nodes.span));\n        }\n        const uris = findAll(section, subj, \"hasUri\");\n        contents.push(...uris.map(\n          (uri) => [findValue(section, uri, \"hasPart\"), findValue(section, uri, \"hasType\")]\n        ).filter(([href]) => href !== \"\" && href !== void 0).flatMap(([href, type]) => [\n          pm.text(\" \"),\n          pm.node(\n            \"external_link\",\n            { href },\n            pm.text(`[${type ?? \"link\"}]`)\n          )\n        ]));\n        return pm.node(\"paragraph\", { resourceID: subj }, contents);\n      },\n      \"listItem\": (subj) => {\n        const content = [];\n        const firstPart = findValue(section, subj, \"hasPart\");\n        if (!firstPart) {\n          return void 0;\n        }\n        const firstPartTypes = findAll(section, firstPart, \"type\");\n        if (!firstPartTypes.includes(\"paragraph\")) {\n          console.warn(\"Inserting leading paragraph for valid list item\");\n          content.push(pm.node(\"paragraph\", null, [pm.text(\"_\")]));\n        }\n        content.push(...generateContent(subj, pm.nodes.list_item));\n        return pm.node(\"list_item\", null, content);\n      },\n      \"figure\": (subj) => {\n        const image = findValue(section, subj, \"hasImage\");\n        const imgSrc = image ? findValue(section, image, \"hasSrc\") : void 0;\n        const svg = image ? findValue(section, image, \"hasSvg\") : void 0;\n        const svgContents = svg ? findValue(section, svg, \"hasSVGContents\") : void 0;\n        if (!imgSrc && !svgContents) {\n          console.warn(\"Won\\u2019t create a figure without an image src or SVG contents\", subj);\n          return void 0;\n        }\n        let figureContents = [];\n        if (svgContents) {\n          figureContents.push(\n            pm.node(\"image\", { src: `data:image/svg+xml,${encodeURIComponent(svgContents)}` })\n          );\n        } else if (imgSrc) {\n          figureContents.push(\n            pm.node(\"image\", { src: imgSrc })\n          );\n        }\n        const name = findValue(section, subj, \"hasName\");\n        const caption = name ? findValue(section, name, \"hasPart\") : null;\n        if (caption) {\n          if (hasSubject(section, caption)) {\n            console.warn(\n              \"Figure captions with complex contents are not yet supported, got\",\n              getAllRelations(section, caption)\n            );\n          } else {\n            figureContents.splice(\n              0,\n              0,\n              pm.node(\"figCaption\", null, [pm.text(caption)])\n            );\n          }\n        }\n        return pm.node(\"figure\", { resourceID: subj }, figureContents);\n      }\n    };\n    function makeNodeOrNot(subj, subjType, parent) {\n      if (simpleNodes[subjType]) {\n        const nodeID = simpleNodes[subjType];\n        const nodeType = pm.nodes[nodeID];\n        if (!nodeType) {\n          console.error(\"No node defined in schema\", nodeID);\n          return void 0;\n        }\n        const content = generateContent(subj, nodeType);\n        return pm.node(\n          nodeID,\n          { resourceID: subj },\n          content\n        );\n      } else if (customNodes[subjType]) {\n        return customNodes[subjType](subj);\n      } else {\n        return void 0;\n      }\n    }\n    function generateContent(subject, subjectNodeType) {\n      const allSubparts = (\n        // TODO: subject is really only used to resolve relations,\n        // maybe this can be refactored out of this function.\n        resolveChain(section, [\"hasPart\"], subject).map(([, partValue]) => {\n          if (!partValue.startsWith(\"urn:\")) {\n            if (partValue.trim() !== \"\") {\n              return pm.text(partValue);\n              if (subjectNodeType.inlineContent) {\n                return pm.text(`${partValue} `);\n              } else {\n                return pm.node(\"paragraph\", null, [pm.text(partValue)]);\n              }\n            } else {\n              return void 0;\n            }\n          } else {\n            const types = findAll(section, partValue, \"type\");\n            for (const type of types) {\n              const maybeNode = makeNodeOrNot(partValue, type, subject);\n              if (maybeNode) {\n                return maybeNode;\n              }\n            }\n            return void 0;\n          }\n        }).filter((maybeNode) => maybeNode !== void 0)\n      );\n      if (subjectNodeType.validContent(Fragment.from(allSubparts))) {\n        return allSubparts;\n      } else {\n        if (subjectNodeType.inlineContent && allSubparts.find((node) => !node.isInline)) {\n          console.warn(\"Trying to create a block in inline content node?\", subject, subjectNodeType.name);\n          return allSubparts.map((n) => n.isInline ? n : pm.text(n.textContent));\n        } else if (!subjectNodeType.inlineContent && allSubparts.find((node) => node.isInline)) {\n          if (allSubparts.find((node) => !node.isInline)) {\n            console.error(\"Mixing inline and block content :(\", subject, subjectNodeType.name, allSubparts.filter((node) => !node.isInline).map((n) => n.toString()));\n            return allSubparts.map((n) => n.isInline ? pm.node(\"paragraph\", null, [n]) : n);\n          } else {\n            return [pm.node(\"paragraph\", null, allSubparts)];\n          }\n        } else {\n          return allSubparts;\n          console.error(\"Something went wrong\", subject, subjectNodeType.name);\n        }\n      }\n      console.error(\"Something went wrong, and nothing was generated\", subject, subjectNodeType.name);\n      return [];\n    }\n    const pm = clauseSchema;\n    const docContents = generateContent(ROOT_SUBJECT, pm.nodes.doc);\n    const contentDoc = pm.node(pm.topNodeType, null, [\n      pm.node(\"title\", null, [pm.text(labelInPlainText)]),\n      ...docContents\n    ]).toJSON();\n    return {\n      labelInPlainText,\n      title: titleSchema.node(\"doc\", null, [\n        titleSchema.text(labelInPlainText)\n      ]).toJSON(),\n      contentSchemaID: \"clause\",\n      contentDoc\n    };\n  }\n};\nvar generateCoverPage = (currentLanguage, primaryDocid) => function(bibdata) {\n  const titles = resolveChain(bibdata, [\"hasTitle\", \"hasPart\"]);\n  const plainMainTitles = titles.filter(\n    ([titleID]) => findValue(bibdata, titleID, \"hasType\") === \"main\" && findValue(bibdata, titleID, \"hasFormat\") === \"text/plain\"\n  );\n  const mainTitleInCurrentLanguage = plainMainTitles.find(\n    ([titleID]) => findValue(bibdata, titleID, \"hasLanguage\") === currentLanguage\n  ) ?? titles.find(\n    ([titleID]) => findValue(bibdata, titleID, \"hasFormat\") === \"text/plain\"\n  );\n  if (!mainTitleInCurrentLanguage) {\n    console.error(\"Avialable titles\", JSON.stringify(plainMainTitles));\n    throw new Error(\"Cannot generate cover page: missing main title in current language\");\n  }\n  const editions = resolveChain(bibdata, [\"hasEdition\", \"hasPart\"]);\n  const edition = editions.find(\n    ([editionID]) => findValue(bibdata, editionID, \"hasLanguage\") === currentLanguage\n  )?.[1] ?? editions[0]?.[1];\n  if (!edition) {\n    throw new Error(\"Cannot generate cover page: missing edition\");\n  }\n  const dates = resolveChain(bibdata, [\"hasDate\", \"hasPart\"]);\n  const pubDate = dates.find(\n    ([dateURI]) => findValue(bibdata, dateURI, \"hasType\") === \"published\"\n  )?.[1] ?? \"unknown publication date\";\n  const contributors = resolveChain(bibdata, [\"hasContributor\"]);\n  const authorAndPublisherOrgURIs = contributors.filter(([, contribURI]) => {\n    const roles = resolveChain(bibdata, [\"hasRole\", \"hasType\"], contribURI);\n    return roles.find(([, roleType]) => roleType === \"author\" || roleType === \"publisher\") !== void 0;\n  }).map(([, contribURI]) => findValue(bibdata, contribURI, \"hasOrganization\")).filter((orgURI) => orgURI !== null);\n  const authorsAndPublishers = Array.from(new Set(authorAndPublisherOrgURIs.map(\n    (uri) => resolveChain(bibdata, [\"hasName\"], uri)[0]?.[1]\n  ).filter((name) => name !== void 0)));\n  const author = authorsAndPublishers[0] ?? \"unknown contributors\";\n  const pm = coverBibdataSchema;\n  return {\n    contentSchemaID: \"cover\",\n    primaryLanguageID: currentLanguage,\n    labelInPlainText: mainTitleInCurrentLanguage[1],\n    title: titleSchema.node(\"doc\", null, [\n      titleSchema.text(mainTitleInCurrentLanguage[1])\n    ]).toJSON(),\n    contentDoc: pm.node(\"doc\", null, [\n      pm.node(\"docMeta\", null, [\n        pm.node(\"primaryDocID\", null, [pm.text(primaryDocid)]),\n        pm.node(\"edition\", null, [pm.text(edition)]),\n        pm.node(\"pubDate\", null, [pm.text(pubDate)]),\n        pm.node(\"author\", null, [pm.text(author)])\n      ]),\n      pm.node(\"mainTitle\", null, [pm.text(mainTitleInCurrentLanguage[1])]),\n      // The rest of the main titles, excluding the main one\n      ...plainMainTitles.filter(([uri]) => uri !== mainTitleInCurrentLanguage[0]).map(\n        ([, titleText]) => pm.node(\"someOtherTitle\", null, [pm.text(titleText)])\n      )\n    ]).toJSON()\n  };\n};\nfunction resolveChain(relations, chain, subj_) {\n  if (chain.length === 1) {\n    return relations.filter((rel) => rel[1] === chain[0] && (!subj_ || rel[0] === subj_)).map((rel) => [rel[0], rel[2]]);\n  } else {\n    return relations.filter((rel) => rel[1] === chain[0] && (!subj_ || rel[0] === subj_)).map((rel) => resolveChain(\n      relations,\n      chain.slice(1),\n      rel[2]\n    )).flat();\n  }\n}\nfunction findValue(relations, subj, pred) {\n  return relations.find(([s, p]) => s === subj && p === pred)?.[2] ?? null;\n}\nfunction findAll(relations, subj, pred) {\n  return relations.filter(\n    ([s, p]) => s === subj && (typeof pred === \"string\" && p === pred || pred.includes(p))\n  ).map(([, , o]) => o);\n}\nfunction relativeGraph(relations, subj) {\n  return relations.filter(([s]) => s !== ROOT_SUBJECT).map(([s, p, o]) => [s === subj ? ROOT_SUBJECT : s, p, o]);\n}\nfunction hasSubject(relations, subj) {\n  return relations.find(([s]) => s === subj) !== void 0;\n}\nfunction getAllRelations(relations, subj, depth = void 0, _seen) {\n  const seen = _seen ?? /* @__PURE__ */ new Set();\n  return relations.map(([s, p, o]) => {\n    if (s === subj) {\n      console.debug(\"Got relation\", p, o);\n      const subjectGraph = [\n        [s, p, o]\n      ];\n      if (depth === void 0 || depth > 0) {\n        seen.add(o);\n        subjectGraph.push(...getAllRelations(relations, o, depth ? depth - 1 : depth, seen));\n      }\n      return subjectGraph;\n    } else {\n      return [];\n    }\n  }).flat();\n}\nexport {\n  anafero_dist_file_Volumes_MNFirelight_firelight_packages_metanorma_site_content_ZCVLpq_default as default\n};\n//# sourceMappingURL=index.js.map\n",
    "file:/Volumes/MNFirelight/firelight/packages/plateau-layout": "// ../../../../../private/var/folders/ln/tn8s27hd7pg4_jx4_49rctfc0000gp/T/anafero-dist-file__Volumes_MNFirelight_firelight_packages_plateau_layout-Gootc2/Layout.tsx\nimport React from \"react\";\n\n// ../../../../../private/var/folders/ln/tn8s27hd7pg4_jx4_49rctfc0000gp/T/anafero-dist-file__Volumes_MNFirelight_firelight_packages_plateau_layout-Gootc2/layout.css\nvar overall = \"layout_overall\";\n\n// ../../../../../private/var/folders/ln/tn8s27hd7pg4_jx4_49rctfc0000gp/T/anafero-dist-file__Volumes_MNFirelight_firelight_packages_plateau_layout-Gootc2/Layout.tsx\nvar Layout = React.forwardRef(function({\n  children,\n  nav\n}, ref) {\n  const breadcrumbs = nav.breadcrumbs.map(\n    (link, idx) => /* @__PURE__ */ React.createElement(\"li\", { key: link.path }, /* @__PURE__ */ React.createElement(\"a\", { href: link.path }, link.plainTitle), idx !== 0 ? /* @__PURE__ */ React.createElement(React.Fragment, null, \"\\u2003\") : null)\n  );\n  breadcrumbs?.reverse();\n  return /* @__PURE__ */ React.createElement(\"div\", { className: overall, ref }, children, /* @__PURE__ */ React.createElement(\"nav\", null, /* @__PURE__ */ React.createElement(\"ul\", null, nav.children.map(\n    (link) => /* @__PURE__ */ React.createElement(\"li\", { key: link.path }, /* @__PURE__ */ React.createElement(\"a\", { href: link.path }, link.plainTitle))\n  ))));\n});\nvar Layout_default = Layout;\n\n// ../../../../../var/folders/ln/tn8s27hd7pg4_jx4_49rctfc0000gp/T/anafero-dist-file__Volumes_MNFirelight_firelight_packages_plateau_layout-Gootc2/index.mts\nvar mod = {\n  name: \"Plateau basic layout\",\n  version: \"0.0.1\",\n  layouts: [{\n    name: \"default\",\n    layout: {\n      Component: Layout_default\n    }\n  }]\n};\nvar anafero_dist_file_Volumes_MNFirelight_firelight_packages_plateau_layout_Gootc2_default = mod;\nexport {\n  anafero_dist_file_Volumes_MNFirelight_firelight_packages_plateau_layout_Gootc2_default as default\n};\n//# sourceMappingURL=index.js.map\n"
}